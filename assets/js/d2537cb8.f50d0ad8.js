"use strict";(self.webpackChunkcreate_project_docs=self.webpackChunkcreate_project_docs||[]).push([[7837],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(96540);const o={},i=r.createContext(o);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:t},e.children)}},59303:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"system-architecture/version-control","title":"Version Control","description":"This project will use Github and git for version control. The standard procedure for branch creation involves creating a branch from main, or from whichever exisitng branch is closest/most relevant to the intended functionality of the branch (for example, a branch focused on UI may branch from another branch focused on developing UI if those changes have not been merged to main yet so they can have a bigger picture of the UI to work with as the develop). The branches will be named based on the task or story the branch is working on, such as LandingPageUI or QuestionTextTo_Speech.","source":"@site/docs/system-architecture/version-control.md","sourceDirName":"system-architecture","slug":"/system-architecture/version-control","permalink":"/project-piggyback-learning-team-2/docs/system-architecture/version-control","draft":false,"unlisted":false,"editUrl":"https://github.com/Capstone-Projects-2025-Spring/project-piggyback-learning-team-2/edit/main/documentation/docs/system-architecture/version-control.md","tags":[],"version":"current","lastUpdatedBy":"kripseepatel","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Sequence Diagrams","permalink":"/project-piggyback-learning-team-2/docs/system-architecture/sequence-diagrams"},"next":{"title":"Algorithm Overview","permalink":"/project-piggyback-learning-team-2/docs/system-architecture/algorithms"}}');var o=n(74848),i=n(28453);const s={sidebar_position:7},a="Version Control",c={},h=[{value:"Branch Protection",id:"branch-protection",level:2},{value:"Docusaurus Build",id:"docusaurus-build",level:2}];function l(e){const t={h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"version-control",children:"Version Control"})}),"\n",(0,o.jsx)(t.p,{children:"This project will use Github and git for version control. The standard procedure for branch creation involves creating a branch from main, or from whichever exisitng branch is closest/most relevant to the intended functionality of the branch (for example, a branch focused on UI may branch from another branch focused on developing UI if those changes have not been merged to main yet so they can have a bigger picture of the UI to work with as the develop). The branches will be named based on the task or story the branch is working on, such as Landing_Page_UI or Question_Text_To_Speech."}),"\n",(0,o.jsx)(t.h2,{id:"branch-protection",children:"Branch Protection"}),"\n",(0,o.jsx)(t.p,{children:"This project has three rules for branch protection:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"A pull request is required to merge the contents of a branch with main."}),"\n",(0,o.jsx)(t.li,{children:"Two approvals of a pull request are required before merging of a branch is allowed."}),"\n",(0,o.jsx)(t.li,{children:"Only admins and users with bypass privileges can delete branches."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"docusaurus-build",children:"Docusaurus Build"}),"\n",(0,o.jsx)(t.p,{children:"The Docusaurus will be built from the gh-pages branch based on the contents of the main branch, using the text and configuration details from the Markdown and JSON files to build an HTML-based documentation website for this project."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);